===============================================
ESP32 TEMPERATURE-HUMIDITY MONITORING SYSTEM
MAIN PSEUDOCODE DOCUMENTATION
===============================================

PROJECT: ESP32 Temperature-Humidity Monitoring System
AUTHOR: Generated by Claude Code
DATE: 2025-12-05
DESCRIPTION: Complete pseudocode for multi-task monitoring system with web interface

===============================================
SYSTEM OVERVIEW
===============================================

HARDWARE COMPONENTS:
- ESP32 Development Board
- DHT11 Temperature/Humidity Sensor
- LDR Light Sensor
- NeoPixel LED (GPIO45)
- Manual LED (GPIO48)
- Auto LED (GPIO2)
- I2C LCD Display (16x2)

SOFTWARE ARCHITECTURE:
- FreeRTOS multi-tasking
- WiFi webserver with REST API
- WebSocket real-time communication
- Persistent settings storage
- Temperature alert system

===============================================
MAIN ENTRY POINT
===============================================

SETUP():
    INITIALIZE Serial communication (115200 baud)
    CALL check_info_File(0) to verify configuration
    
    CREATE PARALLEL TASKS:
        TASK 1: temp_humi_monitor (Stack: 2048, Priority: 2)
        TASK 2: task_light_sensor (Stack: 2048, Priority: 2)
        TASK 3: task_lcd (Stack: 2048, Priority: 1)
        TASK 4: webserver_wifi_config_task (Stack: 8192, Priority: 3)
    
    START FreeRTOS scheduler
    PRINT "System initialized, tasks started"

MAIN_LOOP():
    WHILE (system running):
        IF (check_info_File(1) returns true):
            IF (wifiConfig exists AND wifiConfig.isConnected()):
                // WiFi connected - system operational
                CONTINUE normal operation
            ELSE:
                PRINT "WiFi config system will handle connection"
                // Could add CORE_IOT_reconnect() here if needed
        
        DELAY 1000 milliseconds
    END WHILE

===============================================
TEMPERATURE/HUMIDITY MONITORING TASK
===============================================

TASK_TEMP_HUMIDITY(void *pvParameters):
    INITIALIZE DHT11 sensor
    DECLARE local variables: temperature, humidity
    PRINT "Temperature/Humidity monitoring started"
    
    WHILE (task running):
        READ sensor data:
            temperature = DHT11.readTemperature()
            humidity = DHT11.readHumidity()
        
        IF (sensor readings are valid):
            UPDATE global variables:
                glob_temperature = temperature
                glob_humidity = humidity
            
            PRINT "Temperature: {temperature}°C"
            PRINT "Humidity: {humidity}%"
            
            // Check for temperature alerts
            IF (temperature > HIGH_TEMP_THRESHOLD):
                glob_temp_alert = true
            ELSE:
                glob_temp_alert = false
            
        ELSE:
            PRINT "DHT11 sensor read failed"
            SET glob_temperature = NaN
            SET glob_humidity = NaN
            SET glob_temp_alert = false
        
        DELAY 2000 milliseconds (2 second reading interval)
    END WHILE

===============================================
LIGHT SENSOR TASK
===============================================

TASK_LIGHT_SENSOR(void *pvParameters):
    INITIALIZE GPIO pins:
        pinMode(LED_PIN=2, OUTPUT)  // Auto LED
        pinMode(LIGHT_SENSOR_PIN=1, INPUT)  // ADC input
    
    SET digitalWrite(LED_PIN, LOW)  // Start with LED off
    
    DEFINE CONSTANTS:
        LIGHT_THRESHOLD = 500  // Darkness detection threshold
    
    PRINT "Light sensor task started"
    PRINT "Light threshold: {LIGHT_THRESHOLD}"
    PRINT "LED GPIO: {LED_PIN}"
    PRINT "Light sensor GPIO: {LIGHT_SENSOR_PIN}"
    
    WHILE (task running):
        READ light sensor:
            lightLevel = analogRead(LIGHT_SENSOR_PIN)  // 0-4095 range
            glob_light_level = lightLevel
        
        IF (lightLevel < LIGHT_THRESHOLD):
            // Dark environment detected
            IF (glob_led_state == false):
                CALL controlLED(true)
                PRINT "Dark detected (light: {lightLevel}) - LED turned ON"
        ELSE:
            // Bright environment detected
            IF (glob_led_state == true):
                CALL controlLED(false)
                PRINT "Light detected (light: {lightLevel}) - LED turned OFF"
        
        PRINT "Light level: {lightLevel}, LED: {glob_led_state ? 'ON' : 'OFF'}"
        
        DELAY 2000 milliseconds
    END WHILE

FUNCTION controlLED(bool state):
    digitalWrite(LED_PIN, state ? HIGH : LOW)
    glob_led_state = state
    PRINT "LED {state ? 'ON' : 'OFF'}"

===============================================
LCD DISPLAY TASK
===============================================

TASK_LCD_DISPLAY(void *pvParameters):
    INITIALIZE I2C LCD:
        lcd = LiquidCrystal_I2C(0x27, 16, 2)  // Address, columns, rows
        lcd.init()
        lcd.backlight()
        lcd.clear()
    
    DISPLAY startup message:
        lcd.setCursor(0, 0)
        lcd.print("ESP32 Monitor")
        lcd.setCursor(0, 1) 
        lcd.print("Starting...")
        DELAY 2000 milliseconds
    
    WHILE (task running):
        lcd.clear()
        
        // Line 1: Temperature and Humidity
        lcd.setCursor(0, 0)
        IF (glob_temperature is valid):
            lcd.print("T:{glob_temperature}°C H:{glob_humidity}%")
        ELSE:
            lcd.print("T:--°C H:--%")
        
        // Line 2: Light level and IP address
        lcd.setCursor(0, 1)
        lcd.print("L:{glob_light_level}")
        
        IF (WiFi is connected):
            lcd.print(" IP:")
            lcd.print(WiFi.localIP() last octet)
        ELSE:
            lcd.print(" WiFi:--")
        
        DELAY 1000 milliseconds
    END WHILE

===============================================
WIFI WEBSERVER TASK
===============================================

TASK_WEBSERVER(void *pvParameters):
    INITIALIZE webserver components:
        wifiConfig = new WiFiConfigServer(&webServer, &webSocket)
        wifiConfig.begin()
    
    PRINT "WiFi Configuration Server started on port 8080"
    PRINT "Access: http://192.168.4.1:8080 (in AP mode)"
    
    WHILE (task running):
        CALL wifiConfig.loop()  // Handle web requests and updates
        DELAY 100 milliseconds
    END WHILE

CLASS WiFiConfigServer:
    CONSTRUCTOR():
        INITIALIZE member variables:
            ledState = false
            neoState = true  // NeoPixel starts ON
            savedNeoR=0, savedNeoG=255, savedNeoB=0  // Default green
            alertNeoR=255, alertNeoG=0, alertNeoB=0  // Default red
            tempThreshold = 30.0
            isBlinking = false
        
        SETUP hardware:
            pinMode(LED_GPIO=48, OUTPUT)
            digitalWrite(LED_GPIO, LOW)
            
            neoPixel = new Adafruit_NeoPixel(1, NEO_PIN=45, NEO_GRB + NEO_KHZ800)
            neoPixel.begin()
            neoPixel.setPixelColor(0, Color(savedNeoR, savedNeoG, savedNeoB))
            neoPixel.show()
    
    METHOD begin():
        LOAD saved settings from preferences
        SETUP LittleFS file system
        CONFIGURE WebSocket event handlers
        SETUP REST API routes
        START web server
        
        LOAD WiFi credentials from preferences
        IF (credentials exist):
            ATTEMPT WiFi connection
            IF (connection fails):
                START AP configuration mode
        ELSE:
            START AP configuration mode
    
    METHOD loop():
        // Send periodic updates
        EVERY 5 seconds:
            SEND WiFi status to WebSocket clients
        
        EVERY 3 seconds:
            SEND sensor data to WebSocket clients
            UPDATE NeoPixel based on temperature
        
        CALL handleNeoBlinking()  // Handle alert blinking

===============================================
NEOPIXEL TEMPERATURE CONTROL
===============================================

METHOD setNeoColorForTemperature(float temperature):
    IF (temperature > tempThreshold):
        // Start alert mode
        IF (not currently blinking):
            isBlinking = true
            lastBlinkTime = current_time
            blinkState = true
        
        neoState = true
        glob_temp_alert = true
        PRINT "NeoPixel blinking alert color due to high temperature: {temperature}°C"
        
    ELSE:
        // Return to normal mode
        isBlinking = false
        neoPixel.setPixelColor(0, Color(savedNeoR, savedNeoG, savedNeoB))
        neoPixel.show()
        neoState = true
        glob_temp_alert = false
        PRINT "NeoPixel normal color, temperature: {temperature}°C"

METHOD handleNeoBlinking():
    IF (isBlinking):
        current_time = millis()
        IF (current_time - lastBlinkTime > 500):  // Blink every 500ms
            blinkState = !blinkState
            lastBlinkTime = current_time
            
            IF (blinkState):
                // Show alert color
                neoPixel.setPixelColor(0, Color(alertNeoR, alertNeoG, alertNeoB))
            ELSE:
                // Turn off
                neoPixel.setPixelColor(0, Color(0, 0, 0))
            
            neoPixel.show()

===============================================
REST API ENDPOINTS
===============================================

SETUP REST API routes:
    GET / → Serve dashboard.html
    GET /sensors → Return sensor data JSON
    GET /status → Return WiFi status JSON  
    GET /leds → Return LED status JSON
    GET /light → Return light sensor JSON
    GET /alert → Return alert settings JSON
    GET /wifi-config → Serve WiFi configuration page

API_ENDPOINT /sensors:
    RETURN JSON:
    {
        "temperature": glob_temperature,
        "humidity": glob_humidity,
        "light_level": glob_light_level,
        "led_state": glob_led_state,
        "temp_alert": glob_temp_alert,
        "timestamp": millis(),
        "valid": !isnan(glob_temperature) && !isnan(glob_humidity)
    }

API_ENDPOINT /status:
    RETURN JSON:
    {
        "connected": WiFi.isConnected(),
        "ssid": WiFi.SSID(),
        "ip": WiFi.localIP().toString(),
        "rssi": WiFi.RSSI(),
        "config_mode": isConfigMode
    }

API_ENDPOINT /leds:
    RETURN JSON:
    {
        "led_state": ledState,
        "neo_state": neoState,
        "led_pin": LED_GPIO,
        "neo_pin": NEO_PIN,
        "timestamp": millis()
    }

API_ENDPOINT /alert:
    RETURN JSON:
    {
        "alert_r": alertNeoR,
        "alert_g": alertNeoG,
        "alert_b": alertNeoB,
        "alert_hex": alertNeoHex,
        "temp_threshold": tempThreshold,
        "current_temp": glob_temperature,
        "temp_alert": glob_temp_alert
    }

===============================================
WEBSOCKET MESSAGE HANDLERS
===============================================

WEBSOCKET_EVENT_HANDLER(client_id, event_type, data):
    SWITCH (event_type):
        CASE WS_EVT_CONNECT:
            PRINT "WebSocket client #{client_id} connected"
            SEND initial data to client:
                - WiFi status
                - WiFi networks list
                - Sensor data
                - LED status
                - Light sensor data
                - Alert settings
        
        CASE WS_EVT_DISCONNECT:
            PRINT "WebSocket client #{client_id} disconnected"
        
        CASE WS_EVT_DATA:
            CALL handleWebSocketMessage(data)

FUNCTION handleWebSocketMessage(data):
    PARSE JSON from data
    action = json["action"]
    
    SWITCH (action):
        CASE "control_led":
            state = json["state"]
            CALL setLEDState(state)
            SEND LED status update to all clients
        
        CASE "control_neo":
            state = json["state"] 
            IF (not isBlinking):  // Only allow manual control when not alerting
                CALL setNeoState(state)
                SEND LED status update to all clients
        
        CASE "preview_neo_color":
            r = json["r"], g = json["g"], b = json["b"]
            IF (not isBlinking):
                CALL setNeoColor(r, g, b)
                SEND preview confirmation to client
        
        CASE "save_neo_color":
            r = json["r"], g = json["g"], b = json["b"], hex = json["hex"]
            success = CALL saveNeoColor(r, g, b, hex)
            IF (not isBlinking):
                CALL setNeoColor(r, g, b)  // Apply immediately
            SEND save confirmation to client
        
        CASE "save_temp_threshold":
            threshold = json["threshold"]
            success = CALL saveTempThreshold(threshold)
            SEND threshold save confirmation to client
        
        CASE "get_sensors":
            SEND current sensor data to client
        
        CASE "get_status":
            SEND current WiFi status to client
        
        CASE "get_leds":
            SEND current LED status to client
        
        CASE "get_alert_settings":
            SEND current alert settings to client

===============================================
PERSISTENT SETTINGS MANAGEMENT
===============================================

FUNCTION saveNeoColor(r, g, b, hex):
    savedNeoR = r, savedNeoG = g, savedNeoB = b
    savedNeoHex = hex
    
    preferences.putUChar("neo_r", r)
    preferences.putUChar("neo_g", g) 
    preferences.putUChar("neo_b", b)
    preferences.putString("neo_hex", hex)
    
    PRINT "NeoPixel color saved: RGB({r}, {g}, {b}) = {hex}"
    RETURN true

FUNCTION saveTempThreshold(threshold):
    tempThreshold = threshold
    HIGH_TEMP_THRESHOLD = threshold  // Update global
    
    preferences.putFloat("temp_threshold", threshold)
    
    PRINT "Temperature threshold saved: {threshold}°C"
    RETURN true

FUNCTION loadSavedSettings():
    // Load NeoPixel colors
    savedNeoR = preferences.getUChar("neo_r", 0)      // Default red=0
    savedNeoG = preferences.getUChar("neo_g", 255)    // Default green=255  
    savedNeoB = preferences.getUChar("neo_b", 0)      // Default blue=0
    savedNeoHex = preferences.getString("neo_hex", "#00ff00")
    
    // Load alert colors  
    alertNeoR = preferences.getUChar("alert_r", 255)   // Default red=255
    alertNeoG = preferences.getUChar("alert_g", 0)     // Default green=0
    alertNeoB = preferences.getUChar("alert_b", 0)     // Default blue=0
    alertNeoHex = preferences.getString("alert_hex", "#ff0000")
    
    // Load temperature threshold
    tempThreshold = preferences.getFloat("temp_threshold", 30.0)
    HIGH_TEMP_THRESHOLD = tempThreshold
    
    PRINT "Settings loaded successfully"

===============================================
SYSTEM DATA FLOW
===============================================

SENSOR READING FLOW:
DHT11 Task → glob_temperature, glob_humidity
Light Task → glob_light_level, glob_led_state  
     ↓
Global Variables (shared memory)
     ↓
LCD Task (display) + WebServer Task (web interface)
     ↓
WebSocket clients receive real-time updates

CONTROL FLOW:
Web Dashboard → WebSocket message → WebServer Task
     ↓
Hardware control (LED, NeoPixel)
     ↓  
Status update → WebSocket → Dashboard update

ALERT FLOW:
Temperature reading → Compare with threshold → Update glob_temp_alert
     ↓
NeoPixel controller → Start/stop blinking → Visual feedback
     ↓
Dashboard update → Color change → User notification

===============================================
HARDWARE PIN ASSIGNMENTS
===============================================

ESP32 GPIO PIN MAPPING:
GPIO1  → Light Sensor (ADC1_CH0) - Analog input
GPIO2  → Auto LED Output - Digital output
GPIO21 → I2C SDA (LCD Display) - I2C data
GPIO22 → I2C SCL (LCD Display) - I2C clock  
GPIO45 → NeoPixel Data Line - Digital output
GPIO48 → Manual LED Output - Digital output
DHT11  → DHT11 Data Pin - Digital I/O
VCC    → 3.3V Power Supply
GND    → Ground connections

SENSOR CONNECTIONS:
DHT11: VCC→3.3V, GND→GND, DATA→DHT_PIN
LDR: One end→3.3V, Other end→GPIO1 + 10kΩ→GND
NeoPixel: VCC→5V, GND→GND, DI→GPIO45
LCD: VCC→5V, GND→GND, SDA→GPIO21, SCL→GPIO22
LEDs: Anode→GPIO (via resistor), Cathode→GND

===============================================
SYSTEM FEATURES SUMMARY
===============================================

MONITORING CAPABILITIES:
✅ Real-time temperature monitoring (DHT11)
✅ Real-time humidity monitoring (DHT11)  
✅ Ambient light monitoring (LDR sensor)
✅ Local LCD display (16x2 I2C)
✅ Web dashboard with live updates
✅ REST API for external integration

CONTROL FEATURES:
✅ Manual LED control via web interface
✅ NeoPixel color customization
✅ Temperature alert threshold configuration  
✅ WiFi network configuration interface
✅ Automatic light-based LED control

ALERT SYSTEM:
✅ Visual temperature alerts (dashboard color change)
✅ NeoPixel blinking when temperature exceeds threshold
✅ Configurable alert color and temperature threshold
✅ Automatic return to normal when temperature drops
✅ Real-time status updates via WebSocket

CONNECTIVITY:
✅ WiFi AP mode for initial configuration
✅ WiFi Station mode for network operation
✅ HTTP REST API endpoints
✅ WebSocket real-time communication
✅ Persistent configuration storage
✅ Multi-client web interface support

TECHNICAL SPECIFICATIONS:
- Platform: ESP32 (ESP-IDF/Arduino Framework)
- RTOS: FreeRTOS multi-tasking
- Web Framework: ESPAsyncWebServer
- Communication: HTTP REST API + WebSocket
- Storage: ESP32 Preferences (NVS)
- Display: I2C LCD 16x2
- Sensors: DHT11, LDR photoresistor
- Actuators: NeoPixel LED, standard LEDs
- Power: 3.3V/5V mixed voltage system

===============================================
END OF PSEUDOCODE DOCUMENTATION
===============================================

This pseudocode represents the complete system architecture
and implementation logic for the ESP32 Temperature-Humidity  
Monitoring System with web interface and alert capabilities.

Author: Generated by Claude Code
Date: 2025-12-05
Project: ESP32 Multi-sensor Monitoring System